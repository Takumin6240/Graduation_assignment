# 第3章 提案

## 3.1 Scratch学習支援システム概要

### 3.1.1 システムの目的

本研究で提案するシステムは、小学校3〜6年生を対象とした、試行錯誤型のプログラミング学習を支援するWebアプリケーションである。近年、プログラミング教育が小学校で必修化され、Scratchを用いた学習が広く行われている。しかし、従来の学習方法では、完成見本を模倣する形式が主流であり、学習者が自ら考え試行錯誤する機会が不足している。この結果、プログラミング的思考が十分に育成されないという課題が指摘されている。

本システムでは、以下の3つのアプローチによりこの課題の解決を図る。

第一に、4種類の問題タイプ（穴埋め式、予測問題、間違い探し、ミッション型）を用意し、段階的に思考力を育成する。これにより、単なる模倣ではなく、プログラムの動作原理を理解し、自ら問題を解決する能力を養うことができる。

第二に、Scratchプロジェクトファイル（.sb3形式）の自動採点機能により、学習者は即座にフィードバックを受け取ることができる。本システムの採点エンジン（バージョン2.3）は、単なる構文比較ではなく、プログラムの意味的等価性を判定する。これにより、学習者が独自の変数名や異なる実装方法を用いた場合でも、正しく評価することが可能である。

第三に、学年別適応型ヒント機能により、学習者の発達段階に応じた支援を提供する。3年生向けには平易な言葉でヒントを提示し、6年生向けにはより技術的な説明を行うことで、各学習者に最適な学習支援を実現する。

### 3.1.2 システムの全体像

本システムは、図3.1に示すように、フロントエンド、バックエンド、データベースの3層アーキテクチャで構成される。

```
┌───────────────────────────────────────────┐
│          学生（ブラウザ）                 │
│  ・問題を解く                             │
│  ・SB3ファイルをアップロード               │
│  ・フィードバックを受け取る                │
└────────────────┬──────────────────────┘
                 │ HTTPS (JWT認証)
                 ↓
┌───────────────────────────────────────────┐
│      フロントエンド (React)               │
│  ・React 18 + TypeScript                  │
│  ・Tailwind CSS                           │
│  ・React Router v6                        │
│  ・JWT認証、状態管理                       │
└────────────────┬──────────────────────┘
                 │ REST API (JSON)
                 ↓
┌───────────────────────────────────────────┐
│     バックエンド (Node.js + Express)      │
│  ・ビジネスロジック                        │
│  ・JWT認証・認可                          │
│  ・Multer（ファイルアップロード）          │
│  ・JSZip（SB3解析）                       │
│  ・採点エンジン（v2.3）★                 │
└────────────────┬──────────────────────┘
                 │ SQL
                 ↓
┌───────────────────────────────────────────┐
│      データベース (PostgreSQL)            │
│  ・ユーザー情報                           │
│  ・問題データ（JSONB形式でSB3保存）        │
│  ・提出記録・学習ログ（研究用）            │
└───────────────────────────────────────────┘
```
図3.1: システム全体構成図

システムは2種類のユーザーをサポートする。**学生ユーザー**は、問題を解き、フィードバックを受け取り、自身の学習進捗を確認できる。**管理者ユーザー**（教員・研究者）は、問題の作成・編集、学習データの分析、統計情報の閲覧が可能である。

本システムの主要機能は以下の通りである。

1. **章・問題管理機能**: 学習内容を章ごとに構成し、段階的な学習を支援
2. **Scratchファイルのアップロード・自動採点機能**: .sb3ファイルを解析し、即座に採点結果を返す
3. **リアルタイムフィードバック機能**: 採点結果に基づき、詳細なフィードバックを提供
4. **学年別ヒント表示機能**: 学習者の学年に応じたヒントを表示
5. **ランク・ポイントシステム**: ゲーミフィケーション要素により学習意欲を向上
6. **学習進捗の可視化**: 章別の進捗状況をグラフで表示
7. **詳細な学習ログ記録**: すべての試行を記録し、研究データとして活用

### 3.1.3 学習の流れ

本システムにおける学習の流れを図3.2に示す。

```
┌─────────┐
│ 1. ログイン │
└─────┬───┘
      │ JWT発行
      ↓
┌─────────────┐
│ 2. 章選択     │
│  （章一覧表示）│
└─────┬───────┘
      │
      ↓
┌─────────────┐
│ 3. 問題選択   │
│  （問題一覧） │
└─────┬───────┘
      │
      ↓
┌─────────────────────┐
│ 4. 問題理解             │
│  ・問題文を読む          │
│  ・初期SB3ダウンロード   │
└─────┬───────────────┘
      │
      ↓
┌──────────────────────────┐
│ 5. Scratchでプログラム作成  │
│  ・https://scratch.mit.edu/ │
│  ・初期SB3を開く            │
│  ・プログラムを修正・作成    │
│  ・.sb3ファイルとして保存   │
└──────┬───────────────────┘
       │
       ↓
┌──────────────┐
│ 6. 提出         │
│  SB3アップロード │
└──────┬───────┘
       │ ファイル解析・採点（数秒）
       ↓
┌──────────────────────┐
│ 7. フィードバック受け取り │
│  ・スコア表示            │
│  ・詳細フィードバック     │
│  ・ヒント（必要時）       │
└──────┬───────────────┘
       │
       ├─→ 不正解 → 修正して再提出（ステップ5へ）
       │
       └─→ 正解 → 経験値獲得、次の問題へ（ステップ3へ）
```
図3.2: システムにおける学習フロー

学習者はまず、ユーザー名とパスワードでログインする（ステップ1）。認証が成功すると、JWT（JSON Web Token）が発行され、以降の通信で使用される。

次に、学習したい章を選択し（ステップ2）、その章に含まれる問題一覧から取り組む問題を選択する（ステップ3）。問題詳細画面で問題文を読み、初期Scratchプロジェクトファイル（.sb3形式）をダウンロードする（ステップ4）。

学習者は、Scratch公式サイト（https://scratch.mit.edu/）で初期ファイルを開き、問題の指示に従ってプログラムを修正・作成する（ステップ5）。完成したら、.sb3ファイルとして保存し、本システムにアップロードする（ステップ6）。

バックエンドでは、アップロードされたファイルを解析し、自動採点を実行する。採点には通常数秒を要する。採点結果として、スコア（0〜100点）、正誤判定、詳細なフィードバックが生成される（ステップ7）。

不正解の場合、学習者はフィードバックを参考にプログラムを修正し、再度提出できる。正解の場合、ポイントを獲得し、次の問題に進むことができる。このサイクルを繰り返すことで、段階的にプログラミング的思考を育成する。

---

## 3.2 使用技術

本システムの開発において採用した技術スタックを、開発環境、フロントエンド、バックエンド、データベースの観点から説明する。

### 3.2.1 開発技術

本システムの開発環境および関連技術を表3.1に示す。

| カテゴリ | 技術 | 説明 |
|---------|------|------|
| 開発ツール | Monaca | クラウド型統合開発環境 |
| コンテナ技術 | Docker Compose 3.8 | 開発環境の統一・再現性確保 |
| バージョン管理 | Git | ソースコード管理 |
| 開発OS | Windows 11 (WSL2) | 開発環境 |

表3.1: 開発環境技術

Docker Composeを採用した理由は、開発環境の統一と再現性の確保にある。本システムは、PostgreSQL、Node.jsバックエンド、Reactフロントエンドの3つのコンテナで構成され、`docker-compose up`のワンコマンドで全環境を起動できる。これにより、異なる開発者間での環境差異を最小化し、開発効率を向上させている。

### 3.2.2 フロントエンド

フロントエンドの技術スタックを表3.2に示す。

| 技術 | バージョン | 用途 |
|-----|-----------|------|
| React | 18.x | UIフレームワーク |
| TypeScript | 4.x | 型安全な開発 |
| Tailwind CSS | 3.x | スタイリング |
| React Router | 6.x | ルーティング |
| Axios | 1.x | HTTP通信 |

表3.2: フロントエンド技術スタック

**React 18**を採用した理由は、コンポーネント指向の設計により、保守性と再利用性が高いためである。ユーザーインターフェースを小さな部品（コンポーネント）に分割し、それらを組み合わせることで、複雑な画面を構築している。

**TypeScript**を採用した理由は、静的型チェックによりバグを開発時に発見できるためである。JavaScriptの動的型付けでは、実行時にしかエラーが発見できないが、TypeScriptでは開発時に型の不整合を検出できる。特に、APIレスポンスの型定義により、フロントエンド・バックエンド間のデータ構造の整合性を保証している。

**Tailwind CSS**を採用した理由は、ユーティリティファーストのアプローチにより、迅速なUI開発が可能なためである。従来のCSSフレームワークでは、あらかじめ定義されたコンポーネントを使用するが、Tailwind CSSでは、小さなユーティリティクラスを組み合わせてスタイルを構築する。これにより、カスタマイズ性が高く、小学生向けの親しみやすいデザインを実現している。

**React Router v6**は、シングルページアプリケーション（SPA）におけるページ遷移を管理する。ブラウザの戻る・進むボタンにも対応し、ユーザー体験を向上させている。

**Axios**は、HTTPクライアントライブラリであり、バックエンドAPIとの通信を担当する。インターセプター機能により、すべてのリクエストに自動的にJWTトークンを付与し、認証を実現している。

### 3.2.3 バックエンド

バックエンドの技術スタックを表3.3に示す。

| 技術 | バージョン | 用途 |
|-----|-----------|------|
| Node.js | 18.x | サーバーサイド実行環境 |
| Express.js | 4.x | Webフレームワーク |
| PostgreSQL | 14.x | リレーショナルデータベース |
| JWT | - | 認証トークン |
| Multer | 1.x | ファイルアップロード処理 |
| JSZip | 3.x | SB3ファイル（ZIP）の解析 |
| bcrypt | 5.x | パスワードハッシュ化 |

表3.3: バックエンド技術スタック

**Node.js + Express.js**を採用した理由は、JavaScriptでフロントエンドとバックエンドを統一できるためである。これにより、開発者の学習コストを削減し、開発効率を向上させている。また、Node.jsは非同期I/Oに優れており、複数の学習者が同時にファイルをアップロードする場合でも、効率的に処理できる。

**PostgreSQL**を採用した理由は、JSONB型によりScratchプロジェクトファイルの内容を柔軟に保存できるためである。Scratchのproject.jsonは複雑な階層構造を持つが、JSONB型を用いることで、この構造をそのままデータベースに保存し、高速に検索できる。詳細は3.3.11節で述べる。

**JWT（JSON Web Token）**を採用した理由は、ステートレスな認証を実現できるためである。従来のセッション方式では、サーバー側でセッション情報を保持する必要があるが、JWTではトークン自体に認証情報が含まれているため、サーバー側の負荷が軽減される。また、トークンには有効期限を設定でき、セキュリティを向上させている。

**Multer**は、multipart/form-dataによるファイルアップロードを処理するミドルウェアである。.sb3ファイルのアップロードを受け付け、メモリ上に保持する。ファイルサイズは10MBに制限し、悪意のある大容量ファイルのアップロードを防いでいる。

**JSZip**を採用した理由は、.sb3ファイルが実際にはZIP形式であるためである。JSZipにより、アップロードされた.sb3ファイルを解凍し、中のproject.jsonを取り出す。これにより、Scratchプログラムの内容を解析し、採点エンジンに渡すことができる。

**bcrypt**は、パスワードをハッシュ化するライブラリである。平文パスワードをそのままデータベースに保存すると、データベースが漏洩した際に全ユーザーのパスワードが露出するが、bcryptによるハッシュ化により、この問題を防いでいる。bcryptはsalt（ランダムな文字列）を自動生成し、同じパスワードでも異なるハッシュ値が生成されるため、レインボーテーブル攻撃にも耐性がある。

---

## 3.3 Webアプリケーション内容

本節では、システムの画面構成、データベース設計、機能の詳細について説明する。

### 3.3.1 アプリケーションの流れ（状態遷移図）

本システムの画面遷移を図3.3に示す。システムは、認証状態に応じて、未認証状態、学生認証済み状態、管理者認証済み状態の3つの状態を持つ。

```
             ┌──────────┐
             │ホーム画面│
             └────┬─────┘
                  │
                  │
                  │              
                  ↓             
            ┌──────────┐   
            │ログイン  │    
            └────┬─────┘    
                 │            
                 │ JWT発行
                 ↓
         ┌──────────┐
         │章選択画面│
         └────┬─────┘
              │
              ↓
         ┌──────────┐
         │問題一覧  │
         └────┬─────┘
              │
              ↓
         ┌──────────┐
         │問題詳細  │
         │SB3 DL    │
         └────┬─────┘
              │ SB3アップロード
              ↓
         ┌────────────┐
         │フィードバック│
         │表示         │
         └────┬───────┘
              │
        ┌─────┴─────┐
        │             │
        ↓             ↓
   ┌────────┐   ┌────────┐
   │再挑戦   │   │次の問題│
   │(問題詳細)│   │(問題一覧)│
   └────────┘   └────────┘

     別ルート: 進捗管理画面 ←→ 章選択画面

   [管理者専用]
     管理者ログイン → 管理者ダッシュボード
                    ├→ ユーザー管理
                    ├→ 問題管理
                    └→ データ分析
```
図3.3: システムの状態遷移図

**未認証状態**では、ユーザーはホーム画面とログイン画面にのみアクセスできる。生徒は自分でアカウントを作成することはできず、管理者が作成したユーザー名とパスワードを使用してログインする必要がある。保護されたページ（章選択、問題一覧など）にアクセスしようとすると、React Routerの`ProtectedRoute`コンポーネントにより自動的にログイン画面にリダイレクトされる。

**学生認証済み状態**では、章選択画面から問題一覧、問題詳細、フィードバック表示、進捗管理画面にアクセスできる。管理者専用ページはアクセス不可である。

**管理者認証済み状態**では、管理者ダッシュボード、ユーザー管理、問題管理、データ分析画面にアクセスできる。ユーザー管理画面では、「+ 学生を作成」ボタンをクリックすることで、新しい生徒アカウントを作成できる。作成時に必要な情報は、ユーザー名、パスワード、ニックネーム、学年（3〜6年生）である。作成された生徒アカウントには、作成した管理者のID（`admin_id`）が自動的に紐付けられ、管理者は自分が作成した生徒のデータのみを閲覧・管理できる。これにより、複数の教員や研究者が同一システムを使用する場合でも、データの独立性が保たれる。

### 3.3.2 ホーム画面

ホーム画面は、システムの入口であり、ログインへの誘導を行う。小学生が迷わないよう、シンプルで視認性の高いデザインとしている。

画面には、システムのタイトル「Scratch学習支援システム」、システムの説明「プログラミング的思考を段階的に育成するシステムです」、ログインボタンが配置されている。ログインボタンは大きく、目立つ色（青）で表示されており、小学生でも容易に識別できる。

画面下部には「※ 小学3〜6年生向け」の注記および「※ ログインには、先生から配布されたIDとパスワードを使用してください」の説明が表示され、対象年齢と利用方法を明示している。

実装ファイルは`frontend/src/pages/Home.tsx`である。

### 3.3.3 ログイン画面（生徒用）

ログイン画面は、ユーザー認証を行い、システムへの安全なアクセスを実現する。生徒は、管理者（教員・研究者）が作成したユーザー名とパスワードを使用してログインする。

画面には、ユーザー名入力欄、パスワード入力欄（マスク表示）、ログインボタンが配置されている。各入力欄には、プレースホルダーテキスト（例：「先生から配布されたユーザー名」）が表示され、何を入力すべきか明確にしている。

ログイン処理の流れは以下の通りである。

1. フロントエンドで、ユーザー名とパスワードを取得
2. Axiosを用いて、`POST /api/auth/login`にリクエスト送信
3. バックエンドで、`authController.loginStudent()`が呼び出される
4. データベースのusersテーブルからユーザー情報を取得し、bcryptでパスワードを照合
5. 正しければ、JWTトークン（`role: 'student'`、`userId`を含む）を生成し、レスポンスとして返す
6. フロントエンドで、トークンを`localStorage`に保存
7. 章選択画面に自動遷移

エラーハンドリングとして、ユーザー名またはパスワードが間違っている場合、「ユーザー名またはパスワードが正しくありません」というエラーメッセージを赤字で表示する。セキュリティ上、どちらが間違っているかは明示しない。ネットワークエラーの場合、「接続に失敗しました。しばらくしてからもう一度お試しください」と表示する。

セキュリティ対策として、以下を実施している。

- HTTPS通信により、通信内容を暗号化（本番環境）
- パスワードは平文で送信せず、バックエンドでハッシュと照合
- ログイン失敗時も、具体的なエラー理由を明示しない（ユーザー名の存在確認攻撃を防ぐ）

実装ファイルは`frontend/src/pages/Login.tsx`である。関連APIは`POST /api/auth/login`（`authController.js`:74-122行目）である。

なお、管理者用のログイン画面は別に存在し、`/admin/login`のURLでアクセスできる。管理者ログインでは`POST /api/auth/admin/login`が使用され、JWTトークンに`role: 'admin'`が設定される。

### 3.3.4 管理者によるユーザー作成機能

本システムでは、生徒が自分でアカウントを登録することはできない。管理者（教員・研究者）が「ユーザー管理」画面から生徒のアカウントを作成する仕組みを採用している。この設計により、以下の利点が得られる。

1. **アカウント管理の一元化**: 教員が生徒のアカウントを管理することで、不正なアカウント作成を防ぐ
2. **データの独立性**: 各管理者は自分が作成した生徒のデータのみを閲覧でき、プライバシーが保護される
3. **簡単な配布**: 教員が生徒にユーザー名とパスワードを配布するだけで利用開始できる

**ユーザー作成の画面と操作**

管理者が「ユーザー管理」画面（`/admin/users`）にアクセスすると、以下の要素が表示される。

- **ユーザー一覧テーブル**: 自分が作成した全生徒のリスト（ユーザー名、ニックネーム、学年、ランク、ポイント、提出数、正解率、平均スコア、登録日）
- **学年フィルター**: 3年生〜6年生でフィルタリング可能
- **「+ 学生を作成」ボタン**: クリックするとモーダルウィンドウが表示される

**学生作成モーダルの入力項目**

モーダルウィンドウには、以下の入力項目が配置されている。

1. **ユーザー名**（必須）: ログインIDとして使用。半角英数字、一意である必要がある
2. **パスワード**（必須）: 生徒に配布するパスワード。6文字以上
3. **ニックネーム**（必須）: システム上で表示される名前。ひらがな、カタカナ、漢字が使用可能
4. **学年**（必須）: 3年生〜6年生から選択（ドロップダウン）

各入力欄の下部には、入力に関する注意事項が表示される（例：「※ 生徒に配布するパスワードです」）。

**作成処理の流れ**

1. 管理者がモーダルで必要情報を入力し、「作成」ボタンをクリック
2. フロントエンドで入力内容をバリデーション
3. Axiosを用いて、`POST /api/admin/students`にリクエスト送信（JWTトークンに管理者IDが含まれる）
4. バックエンドで、`adminController.createStudent()`が呼び出される（`adminController.js`:7-61行目）
5. ユーザー名の重複チェック（usersテーブル内で一意である必要がある）
6. bcryptでパスワードをハッシュ化
7. データベースのusersテーブルに保存
   - `admin_id`: リクエストを送信した管理者のID（自動設定）
   - `rank`: 1（初期値）
   - `points`: 0（初期値）
   - その他の入力情報
8. 作成成功のレスポンスを返す
9. フロントエンドでモーダルを閉じ、ユーザー一覧を再取得して表示を更新

**バリデーション**

以下のバリデーションが実施される。

- **ユーザー名**: 既に使用されていないかをバックエンドで確認。重複している場合、「このユーザー名は既に使用されています」というエラーメッセージを表示
- **パスワード**: 6文字以上であることをフロントエンドで確認
- **学年**: 3〜6の範囲であることをバックエンドで確認
- **全項目**: 必須入力であることを確認

**作成されたアカウントの配布**

作成が完了すると、管理者はユーザー名とパスワードを生徒に配布する。生徒はこれらの情報を使用してログイン画面（`/login`）からシステムにアクセスできる。

**実装ファイル**

- フロントエンド: `frontend/src/pages/AdminUsers.tsx`（24-73行目、243-325行目）
- バックエンドAPI: `POST /api/admin/students`（`backend/src/routes/admin.js`:40行目）
- コントローラー: `backend/src/controllers/adminController.js`の`createStudent`関数（7-61行目）

**データの独立性**

作成された生徒アカウントには、作成した管理者のID（`admin_id`）が紐付けられる。管理者が「ユーザー管理」画面やダッシュボードでデータを閲覧する際、バックエンドでは`WHERE admin_id = $1`のクエリにより、自分が作成した生徒のデータのみが返される（`adminController.js`:81行目、149行目など）。これにより、複数の教員や研究者が同一システムを使用する場合でも、データの独立性が保たれる。

### 3.3.5 章選択画面

章選択画面は、学習する章を選択する画面である。

画面上部には、「ようこそ、〇〇さん！ ランク: 5」のように、ユーザーのニックネームと現在のランクが表示される。これにより、学習者は自分の成長を実感できる。

画面中央には、章のリストがカード形式で表示される。各カードには、以下の情報が含まれる。

- 章のタイトル（例：「第1章: プログラムの基本」）
- 章の説明
- 進捗状況（例：「5/8問クリア」）
- 難易度（星の数で表示、1〜5）

章をクリックすると、その章の問題一覧画面に遷移する。

画面下部には、「進捗を見る」ボタンと「ログアウト」ボタンが配置されている。進捗を見るボタンをクリックすると、進捗管理画面に遷移する。ログアウトボタンをクリックすると、`localStorage`からトークンを削除し、ホーム画面に戻る。

データ取得は、`GET /api/problems/chapters`により行われる。レスポンスには、各章の情報と、現在のユーザーの進捗情報が含まれる。

実装ファイルは`frontend/src/pages/Chapters.tsx`である。

### 3.3.6 問題一覧画面

問題一覧画面は、選択した章に含まれる問題の一覧を表示する。

画面上部には、章のタイトルと説明が表示される（例：「第1章: プログラムの基本」「順次処理の理解から始めよう！」）。

画面中央には、問題のリストがカード形式で表示される。各カードには、以下の情報が含まれる。

- 問題番号とタイトル（例：「1. ネコを10歩動かそう」）
- 問題タイプのアイコン（[穴埋め]、[予測]、[間違い探し]、[ミッション]）
- 難易度（星の数、1〜5）
- クリア状況（✓ クリア済み（スコア）または → 未クリア）

クリア済みの問題は、緑色で表示され、スコアが併記される。未クリアの問題は、グレーで表示される。

問題をクリックすると、問題詳細画面に遷移する。クリア済みの問題も再挑戦可能であり、より高いスコアを目指すことができる。

画面下部には、「章選択に戻る」ボタンが配置されている。

データ取得は、`GET /api/problems/chapters/:chapterId/problems`により行われる。レスポンスには、各問題の情報と、現在のユーザーの提出状況（クリア済みか、最高スコア）が含まれる。

実装ファイルは`frontend/src/pages/ProblemList.tsx`である。

### 3.3.7 問題詳細画面

問題詳細画面は、問題文の表示、初期Scratchファイルのダウンロード、完成ファイルのアップロードを行う。

画面には、以下の要素が配置されている。

1. **問題情報**: 問題番号、タイトル、タイプ、難易度
2. **問題文**: 問題の内容、何を実現すべきかの説明
3. **学習のポイント**: この問題で学ぶべき概念（例：「『動き』ブロックの使い方」「数値の入力方法」）
4. **初期ファイルダウンロードボタン**: クリックすると、初期Scratchプロジェクト（.sb3形式）をダウンロードできる
5. **ファイルアップロード欄**: 完成した.sb3ファイルを選択する。ドラッグ&ドロップにも対応
6. **提出ボタン**: アップロードしたファイルを採点のために送信
7. **ヒントボタン**: クリックすると、学年に応じたヒントがモーダルウィンドウで表示される

初期ファイルダウンロードの処理は以下の通りである。

1. `GET /api/problems/:problemId`で問題情報を取得
2. レスポンスに含まれる`initial_sb3_data`（JSONB形式）をJavaScriptオブジェクトとして取得
3. JSZipライブラリを用いて、project.jsonをZIP形式に圧縮
4. Blobとしてダウンロード（ファイル名：`problem_1_initial.sb3`）

ファイルアップロード処理は以下の通りである。

1. ユーザーが.sb3ファイルを選択
2. フロントエンドで、ファイルが.sb3形式であることを確認
3. FormDataオブジェクトを作成し、ファイルを追加
4. `POST /api/submissions/problems/:problemId/submit`に送信
5. バックエンドで採点処理が実行される（詳細は3.4節で説明）
6. 採点結果が返ってくるまで、ローディング表示（「採点中...」）
7. 採点完了後、フィードバック表示画面に遷移

ヒント表示機能は、学年別適応型である。ユーザーの学年に応じて、異なる表現のヒントが表示される。例えば、3年生向けには「みどりいろの『うごき』のブロックをつかうよ」、6年生向けには「motion_movestepsブロックのパラメータを10に設定」のように、発達段階に応じた説明を行う。

ヒントは、`GET /api/problems/:problemId/hints`で取得される。レスポンスには、現在のユーザーの学年に対応するヒントのみが含まれる。

実装ファイルは`frontend/src/pages/ProblemDetail.tsx`および`frontend/src/components/HintBubble.tsx`である。

### 3.3.8 提出・フィードバック画面

提出・フィードバック画面は、採点結果と詳細なフィードバックを表示する。

画面上部には、スコア（0〜100点）と結果（正解/不正解）が大きく表示される。スコアは、円グラフまたはプログレスバーで視覚的に示される。

画面中央には、フィードバックセクションが配置される。フィードバックは、サマリー、詳細、ヒントの3つの部分から構成される。

**1. サマリー**
スコアに応じた総合評価が表示される。

- 100点: 「完璧です！」
- 90〜99点: 「あともう一歩！」
- 80〜89点: 「よくできました！」
- 60〜79点: 「もう一息！」
- 0〜59点: 「もう一度チャレンジしてみましょう」

また、v2.3では、エラーが3個以上ある場合、問題の多いカテゴリのサマリーが表示される（例：「問題の多いカテゴリ: 順序(6個)、動き(2個)、データ(2個)」）。

**2. 詳細フィードバック**
採点エンジンが生成した詳細なフィードバックが表示される。フィードバックには、以下の3種類がある。

- **✓ 成功（Success）**: 緑色で表示。正しく実装された部分を褒める。v2.3では表示しない（間違いに集中するため）
- **⚠ 警告（Warning）**: 黄色で表示。部分的に正しいが改善の余地がある
- **✗ エラー（Error）**: 赤色で表示。明確な間違いを指摘

v2.3では、エラーと警告を優先度順に表示する。優先度は以下の通り定義される。

- CRITICAL（優先度3）: ブロックが完全に欠けている
- HIGH（優先度2）: 値が大幅に間違っている
- MEDIUM（優先度1）: 値が少し違う、余分な要素がある

**3. ヒント**
改善のための具体的なヒントが最大3個表示される。ヒントは、優先度順にソートされ、重複が削除される。

例：
```
1. 「動き」カテゴリから「右に○度回す」ブロックを追加してみましょう
2. 「データ」カテゴリから「○を○ずつ変える」ブロックを追加してみましょう
3. 「制御」カテゴリから「○秒待つ」ブロックを追加してみましょう
```

画面下部には、「もう一度挑戦」ボタンと「次の問題へ」ボタンが配置されている。もう一度挑戦ボタンをクリックすると、問題詳細画面に戻る。次の問題へボタンをクリックすると、次の問題の詳細画面に遷移する（章の最後の問題の場合、問題一覧画面に戻る）。

実装ファイルは`frontend/src/components/FeedbackDisplay.tsx`である。

### 3.3.9 進捗管理画面

進捗管理画面は、学習者の学習進捗を可視化する。

画面には、以下のセクションが配置される。

**1. 現在のステータス**
- ランク: 現在のランク
- ポイント: 現在のポイントと次のランクまでの必要ポイント
- プログレスバー: 次のランクまでの進捗を視覚的に表示

**2. 章別進捗**
各章について、完了率がプログレスバーで表示される。
例：「第1章: プログラムの基本 ■■■■■□□□ 5/8問クリア」

**3. 最近の提出履歴**
最近の提出が時系列で表示される。各提出には、以下の情報が含まれる。
- タイムスタンプ（例：「2025/1/15 14:30」）
- 問題名（例：「第1章 問題5」）
- スコア（例：「100点」）
- クリア状況（✓ または 再挑戦）

**4. 学習統計**
- 総提出回数
- 正解率（%）
- 平均スコア

データ取得は、`GET /api/problems/chapters/:chapterId/progress`により行われる。レスポンスには、ユーザーのランク、ポイント、章別進捗、最近の提出履歴、統計情報が含まれる。

実装ファイルは`frontend/src/pages/Progress.tsx`である。

### 3.3.10 管理者ダッシュボード

管理者ダッシュボードは、教員・研究者向けの管理機能を提供する。

画面には、以下のセクションが配置される。

**1. ユーザー統計**
- 総ユーザー数
- アクティブユーザー数（今週）
- 平均ランク

**2. 問題別統計**
各問題について、以下の情報が表示される。
- 正解率（%）
- 平均試行回数
- 平均スコア

正解率が低い問題（例：45%以下）は、赤色で強調表示され、「難易度調整を検討」のメッセージが表示される。

**3. 問題管理**
- 問題を追加ボタン: 新しい問題を作成する画面に遷移
- 問題を編集ボタン: 既存の問題を編集する画面に遷移

**4. データエクスポート**
- 学習ログをCSVでダウンロードボタン: すべての提出記録（`submission_attempts`テーブル）をCSV形式でダウンロード

**5. ユーザー管理**
- ユーザー一覧: 全ユーザーをリスト表示
- 詳細な学習履歴閲覧: 各ユーザーの提出履歴を時系列で確認

実装ファイルは`frontend/src/pages/AdminDashboard.tsx`、`frontend/src/pages/AdminUsers.tsx`、`frontend/src/pages/AdminProblems.tsx`、`frontend/src/pages/AdminAnalytics.tsx`である。

### 3.3.11 データベースについて

本システムのデータベース設計について、ER図、テーブル構造、JSONB型の活用を説明する。

#### 3.3.11.1 データベース管理システムの選定

本システムでは、データベース管理システム（DBMS）として**PostgreSQL 14**を採用した。選定理由は以下の通りである。

第一に、**JSONB型**によりScratchプロジェクトファイルの内容を柔軟に保存できる。Scratchの`.sb3`ファイルは、内部にproject.jsonを含むZIP形式であり、project.jsonは複雑な階層構造（ブロック、変数、スプライトなど）を持つ。これをリレーショナルデータベースの正規化されたテーブルで表現することは困難である。PostgreSQLのJSONB型を用いることで、この階層構造をそのままデータベースに保存できる。

第二に、**JSONB型の高速検索**が可能である。PostgreSQLでは、JSONB型のカラムにGINインデックスを作成することで、JSON内の特定のキーや値を高速に検索できる。本システムでは、特定のブロック（例：`motion_movesteps`）を含む問題を検索する際に、この機能を活用している。

第三に、**トランザクション処理の堅牢性**である。複数の学習者が同時に提出する場合、データの整合性を保つ必要がある。PostgreSQLは、ACID特性（原子性、一貫性、独立性、永続性）を満たしており、信頼性が高い。

第四に、**拡張性**である。将来的に学習者数が増加した場合でも、PostgreSQLはスケールアップ（サーバーのスペックを向上）およびスケールアウト（レプリケーション）に対応できる。

#### 3.3.11.2 ER図

本システムのER図を図3.4に示す。

```
┌─────────┐
│ admins  │ 1 ──── M ┌────────┐
│ (管理者)│           │ users  │
└─────────┘           │(学生)  │
                      └───┬────┘
                          │ M
                          │
┌─────────┐               │
│chapters │ 1 ──── M ┌────┴────┐ M
│ (章)    │          │problems │────── 1 ┌──────┐
└─────────┘          │(問題)   │          │hints │
                     └────┬────┘          │(ヒント)│
                          │ 1             └──────┘
                          │
                          │ M
                     ┌────┴──────────┐
                     │                │
                ┌────┴──────┐  ┌─────┴──────────┐
                │submissions│  │submission_     │
                │(最終提出) │  │attempts        │
                │           │  │(全試行記録)    │
                └───────────┘  └────────────────┘
```
図3.4: データベースER図

主要なリレーションは以下の通りである。

- `admins` 1 対 多 `users`: 1人の管理者が複数の学生を管理
- `chapters` 1 対 多 `problems`: 1つの章が複数の問題を含む
- `problems` 1 対 多 `hints`: 1つの問題が複数のヒント（学年別）を持つ
- `users` 多 対 多 `problems`（`submissions`を介して）: 学生が問題に取り組む
- `users` 多 対 多 `problems`（`submission_attempts`を介して）: すべての試行を記録

#### 3.3.11.3 テーブル詳細

本システムの主要なテーブルを以下に示す。

**1. users（学生）**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  nickname VARCHAR(50) NOT NULL,
  admin_id INTEGER REFERENCES admins(id) ON DELETE SET NULL,
  rank INTEGER DEFAULT 1,
  points INTEGER DEFAULT 0,
  grade INTEGER CHECK (grade >= 3 AND grade <= 6),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

- `username`: ログインID。一意制約（UNIQUE）により重複を防ぐ
- `password_hash`: bcryptでハッシュ化されたパスワード
- `nickname`: 画面に表示される名前
- `admin_id`: この学生を管理する管理者のID（NULL可）
- `rank`: 現在のランク（ゲーミフィケーション要素）
- `points`: 現在のポイント。問題を正解することで獲得
- `grade`: 学年（3〜6年生）。ヒントの出し分けに使用

**2. admins（管理者）**

```sql
CREATE TABLE admins (
  id SERIAL PRIMARY KEY,
  admin_username VARCHAR(50) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

- 学生テーブルと分離することで、認証・認可を明確に分離

**3. chapters（章）**

```sql
CREATE TABLE chapters (
  id SERIAL PRIMARY KEY,
  title VARCHAR(500) NOT NULL,
  description TEXT,
  order_number INTEGER NOT NULL,
  image_url VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

- `order_number`: 章の表示順序
- `title`: VARCHAR(500)とし、ルビ（<ruby>タグ）を含む長いタイトルにも対応

**4. problems（問題）**

```sql
CREATE TABLE problems (
  id SERIAL PRIMARY KEY,
  chapter_id INTEGER REFERENCES chapters(id) ON DELETE CASCADE,
  problem_type VARCHAR(20) CHECK (problem_type IN
    ('fill_blank', 'predict', 'find_error', 'mission')),
  title VARCHAR(500) NOT NULL,
  learning_objective TEXT,
  description TEXT NOT NULL,
  initial_sb3_data JSONB,
  correct_sb3_data JSONB,
  correct_answer_x INTEGER,
  correct_answer_y INTEGER,
  scratch_editor_url TEXT DEFAULT 'https://scratch.mit.edu/',
  max_score INTEGER DEFAULT 100,
  difficulty_level INTEGER CHECK (difficulty_level >= 1 AND difficulty_level <= 5),
  order_number INTEGER NOT NULL,
  image_url VARCHAR(500),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(chapter_id, order_number)
);
```

- `problem_type`: 問題タイプ（穴埋め、予測、間違い探し、ミッション）
- `initial_sb3_data`: 初期Scratchプロジェクトファイル（JSONB形式）
- `correct_sb3_data`: 正解Scratchプロジェクトファイル（JSONB形式）
- `correct_answer_x`, `correct_answer_y`: 予測問題用の正解座標
- `difficulty_level`: 難易度（1〜5）
- `UNIQUE(chapter_id, order_number)`: 1つの章内で問題番号が重複しないよう制約

**5. hints（ヒント）**

```sql
CREATE TABLE hints (
  id SERIAL PRIMARY KEY,
  problem_id INTEGER REFERENCES problems(id) ON DELETE CASCADE,
  grade INTEGER CHECK (grade >= 3 AND grade <= 6),
  hint_text TEXT NOT NULL,
  hint_order INTEGER NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(problem_id, grade, hint_order)
);
```

- `grade`: 学年（3〜6）。学年別にヒントを出し分ける
- `hint_order`: ヒントの表示順序
- `UNIQUE(problem_id, grade, hint_order)`: 1つの問題の特定学年で、ヒント番号が重複しないよう制約

**6. submissions（最終提出記録）**

```sql
CREATE TABLE submissions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  problem_id INTEGER REFERENCES problems(id) ON DELETE CASCADE,
  is_correct BOOLEAN NOT NULL,
  score INTEGER NOT NULL,
  total_attempts INTEGER DEFAULT 1,
  hint_usage_count INTEGER DEFAULT 0,
  time_spent INTEGER,
  final_sb3_data JSONB,
  completed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, problem_id)
);
```

- `UNIQUE(user_id, problem_id)`: 1ユーザー・1問題につき1レコード
- 再提出時は、UPSERT（INSERT ON CONFLICT UPDATE）で更新
- `score`: 最高スコアを保存
- `total_attempts`: 累計提出回数

**7. submission_attempts（全試行記録）**

```sql
CREATE TABLE submission_attempts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  problem_id INTEGER REFERENCES problems(id) ON DELETE CASCADE,
  attempt_number INTEGER NOT NULL,
  attempted_sb3_data JSONB,
  is_correct_attempt BOOLEAN NOT NULL,
  error_message TEXT,
  hint_viewed BOOLEAN DEFAULT FALSE,
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

- すべての試行を記録（研究用）
- `attempted_sb3_data`: 提出されたScratchプロジェクトファイル（JSONB形式）
- `attempt_number`: 何回目の提出か
- `timestamp`: 提出日時

#### 3.3.11.4 JSONB型の活用

Scratchプロジェクトファイル（.sb3）の内容は、JSONB型で保存される。以下に、JSONB型の利点とデータ構造の例を示す。

**JSONB型の利点**

1. **階層構造の保存**: Scratchのproject.jsonは、スプライト、ブロック、変数などの階層構造を持つ。JSONB型により、この構造をそのまま保存できる。

2. **高速検索**: GINインデックスにより、JSON内の特定のキーや値を高速に検索できる。例えば、「`motion_movesteps`ブロックを含む問題」を検索する場合、以下のクエリを実行できる。

```sql
SELECT * FROM problems
WHERE correct_sb3_data @> '{"targets": [{"blocks": {"opcode": "motion_movesteps"}}]}'::jsonb;
```

3. **柔軟性**: Scratchのバージョンアップによりproject.jsonの構造が変わっても、テーブル構造を変更する必要がない。

**Scratchプロジェクトファイルのデータ構造例**

```json
{
  "targets": [
    {
      "isStage": false,
      "name": "Sprite1",
      "variables": {
        "var_id_123": ["カウンター", 0]
      },
      "blocks": {
        "block_id_456": {
          "opcode": "motion_movesteps",
          "inputs": {
            "STEPS": [1, [4, "10"]]
          },
          "fields": {},
          "next": "block_id_789"
        },
        "block_id_789": {
          "opcode": "control_wait",
          "inputs": {
            "DURATION": [1, [4, "1"]]
          }
        }
      }
    }
  ]
}
```

- `targets`: スプライトの配列
- `variables`: 変数の定義。キーは変数ID、値は[変数名, 初期値]
- `blocks`: ブロックの定義。キーはブロックID、値はブロックの詳細
- `opcode`: ブロックの種類（例：`motion_movesteps`）
- `inputs`: ブロックの入力値
- `next`: 次に実行されるブロックのID

#### 3.3.11.5 インデックス設計

パフォーマンス向上のため、以下のインデックスを作成している。

```sql
CREATE INDEX idx_users_admin_id ON users(admin_id);
CREATE INDEX idx_submissions_user_id ON submissions(user_id);
CREATE INDEX idx_submissions_problem_id ON submissions(problem_id);
CREATE INDEX idx_attempts_user_id ON submission_attempts(user_id);
CREATE INDEX idx_attempts_problem_id ON submission_attempts(problem_id);
CREATE INDEX idx_hints_problem_id ON hints(problem_id);
CREATE INDEX idx_hints_grade ON hints(grade);
CREATE INDEX idx_problems_chapter_id ON problems(chapter_id);
```

これにより、ユーザーの提出履歴を取得する際（`WHERE user_id = ?`）や、特定問題の統計を取得する際（`WHERE problem_id = ?`）に、全表スキャンを避け、高速に検索できる。

#### 3.3.11.6 トリガーによる自動更新

`updated_at`カラムは、レコードが更新された際に自動的に現在時刻に更新される。これは、PostgreSQLのトリガー機能により実現している。

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

このトリガーにより、アプリケーション側で`updated_at`を明示的に設定する必要がなく、データの整合性が保たれる。

---

## 3.4 バックエンド・フロントエンドの機能分担

本節では、システムの中核である提出・採点処理の詳細なフローを説明する。

### 3.4.1 提出・採点処理の詳細フロー

提出・採点処理の流れを図3.5に示す。

```
[学生ブラウザ]
   │
   │ 1. .sb3ファイルを選択
   ↓
[Frontend: ProblemDetail.tsx]
   │
   │ 2. バリデーション（ファイル形式、サイズ）
   │ 3. FormData作成
   │    const formData = new FormData();
   │    formData.append('sb3File', file);
   ↓
   │ 4. Axios POST リクエスト
   │    POST /api/submissions/problems/:problemId/submit
   │    Headers: { Authorization: Bearer <token> }
   ↓
[Backend: authMiddleware (auth.js)]
   │
   │ 5. JWTトークン検証
   │    - トークンの署名検証
   │    - トークンの有効期限確認
   │    → req.user = { id, username, grade }
   ↓
[Backend: Multer]
   │
   │ 6. ファイル受信・バリデーション
   │    - ファイルサイズチェック（10MB以下）
   │    - ファイル形式チェック（.sb3）
   │    → req.file = { buffer, originalname, ... }
   ↓
[Backend: submissionController.submitSolution()]
   │
   │ 7. JSZipでSB3解析
   │    const zip = await JSZip.loadAsync(req.file.buffer);
   │    const projectJSON = await zip.file('project.json').async('string');
   │    const submittedSB3 = JSON.parse(projectJSON);
   ↓
   │ 8. データベースから正解SB3取得
   │    SELECT correct_sb3_data FROM problems WHERE id = :problemId
   │    → correctSB3
   ↓
[Backend: scratchGradingEngine.js]
   │
   │ 9. 採点エンジン呼び出し
   │    compareScratchPrograms(correctSB3, submittedSB3)
   │
   │ 9-1. プログラムの正規化
   │      normalizeProgram() - 変数名正規化、ブロック抽出
   │
   │ 9-2. 要件抽出
   │      extractRequirements() - 正解SB3から必須ブロックを抽出
   │
   │ 9-3. 変数マッピング（v2.1の核心）
   │      mapVariables() - 変数の使用パターンでマッピング
   │
   │ 9-4. ブロック比較
   │      checkBlocks() - 必須ブロックの存在、パラメータ確認
   │
   │ 9-5. 順序制約チェック
   │      checkOrderConstraints() - ブロックの順序確認
   │
   │ 9-6. フィードバック生成
   │      generateFeedback() - エラー・警告・ヒントを生成
   │
   │ 9-7. スコア計算
   │      calculateScore() - 0〜100点を算出
   │
   │ → { score, isCorrect, feedback }
   ↓
[Backend: submissionController]
   │
   │ 10. submission_attemptsに記録（研究用）
   │     INSERT INTO submission_attempts
   │     (user_id, problem_id, attempt_number, attempted_sb3_data, ...)
   │
   │ 11. submissionsをUPSERT（最高スコア更新）
   │     INSERT INTO submissions (user_id, problem_id, score, ...)
   │     ON CONFLICT (user_id, problem_id)
   │     DO UPDATE SET score = ..., total_attempts = ...
   │
   │ 12. ポイント・ランク更新（正解時のみ）
   │     UPDATE users SET points = points + :earnedPoints
   │     WHERE id = :userId
   │
   │ 13. ログ記録
   │     logger.info(`User ${userId} submitted problem ${problemId}, score: ${score}`)
   ↓
   │ 14. JSON返却
   │     {
   │       success: true,
   │       score: 85,
   │       isCorrect: true,
   │       feedback: {
   │         summary: "85点: よくできました!",
   │         details: [...],
   │         hints: [...]
   │       }
   │     }
   ↓
[Frontend: ProblemDetail.tsx]
   │
   │ 15. フィードバック画面に遷移
   │     navigate('/feedback', { state: { result } })
   ↓
[Frontend: FeedbackDisplay.tsx]
   │
   │ 16. フィードバック表示
   │     - スコアを円グラフで表示
   │     - 詳細フィードバックをリスト表示
   │     - ヒントを表示
   ↓
[学生ブラウザ]
   結果確認
```
図3.5: 提出・採点処理の詳細フロー

### 3.4.2 主要コンポーネントの役割

**フロントエンド**の責務は以下の通りである。

1. **UI表示**: React コンポーネントによる画面描画
2. **ユーザー操作のハンドリング**: ボタンクリック、フォーム入力など
3. **フォームバリデーション**: 入力値の妥当性チェック（クライアント側）
4. **ファイルのアップロード準備**: FormDataオブジェクトの作成
5. **認証状態の管理**: `localStorage`へのJWTトークン保存、`AuthContext`による状態管理
6. **ルーティング**: React Router v6による画面遷移
7. **HTTP通信**: Axiosによるバックエンドとの通信

**バックエンド**の責務は以下の通りである。

1. **ビジネスロジック**: 採点処理、ポイント計算など
2. **認証・認可**: JWTトークンの検証、ユーザー権限の確認
3. **ファイル処理**: Multerによるファイル受信、JSZipによるSB3解析
4. **自動採点**: 採点エンジン（v2.3）による意味的等価性判定
5. **データベース操作**: PostgreSQLへのクエリ実行
6. **ログ記録**: すべての操作を`logs/`ディレクトリに記録

**データベース**の責務は以下の通りである。

1. **データの永続化**: ユーザー情報、問題データ、提出記録の保存
2. **トランザクション管理**: データの整合性保証
3. **JSONB検索**: SB3データ内の特定ブロックの検索

---

## 3.5 自動採点エンジン（v2.3）

本節では、本システムの中核技術である自動採点エンジンの詳細を説明する。採点エンジンは、バージョン2.3が最新であり、意味的等価性の判定、変数マッピング機能、優先度付きフィードバック生成を実現している。

### 3.5.1 採点エンジン概要

**ファイルパス**: `backend/src/services/scratchGradingEngine.js`

**設計思想**

本採点エンジンは、以下の4つの設計思想に基づいて開発された。

**1. セマンティック比較（意味的等価性の判定）**

従来の文字列完全一致による比較ではなく、プログラムの「意味」を理解して比較する。例えば、以下の2つのプログラムは文字列としては異なるが、動作は同じである。

```
正解:
  10歩動かす
  15度回す

生徒:
  15度回す
  10歩動かす
```

本採点エンジンは、ブロックの順序が異なる場合でも、順序を問わないブロック（例：見た目ブロック）については正解と判定する。

**2. 変数名の違いを吸収（v2.1の核心機能）**

小学生は自由な発想で変数名を付ける。正解のプログラムが変数「カウンター」を使用していても、学習者が変数「りんご」を使用している場合、使用パターンが同じであれば正解と判定する。これにより、変数の本質的な理解を評価できる。詳細は3.5.2節で述べる。

**3. 柔軟な評価（パラメータの許容誤差）**

数値パラメータについて、±10%の誤差を許容する。例えば、「10歩動かす」べきところを「9歩動かす」と入力した場合、警告付きで部分点（スコア0.8）を与える。これは、小学生の入力誤差を考慮したものである。

**4. 詳細なフィードバック（v2.3の改善点）**

単に「不正解」と表示するのではなく、どこが違うか、どう修正すべきかを具体的に指摘する。v2.3では、エラーの優先度付け、正解部分の非表示、カテゴリ別サマリーにより、学習者が間違いに集中できるよう改善された。

**主要関数の構成**

採点エンジンの主要関数を図3.6に示す。

```
compareScratchPrograms()  ← エントリーポイント
  │
  ├─ normalizeProgram()  ← プログラムの正規化
  │   ├─ hiraganaToKatakana()  ← ひらがな→カタカナ変換
  │   ├─ normalizeVariableName()  ← 変数名正規化
  │   └─ normalizeNumber()  ← 数値正規化
  │
  ├─ extractRequirements()  ← 正解SB3から要件抽出
  │
  ├─ mapVariables() ★v2.1の核心★
  │   ├─ buildVariableUsagePattern()  ← 変数使用パターン抽出
  │   └─ calculatePatternSimilarity()  ← パターン類似度計算
  │
  ├─ checkBlocks()  ← ブロック比較
  │   ├─ findBlocksByOpcode()  ← 特定ブロックを検索
  │   └─ compareParameters()  ← パラメータ比較（±10%許容）
  │
  ├─ checkOrderConstraints()  ← 順序制約チェック
  │
  ├─ generateFeedback() ★v2.3の改善★
  │   ├─ prioritizeErrors()  ← エラーを優先度順にソート
  │   ├─ generateCategorySummary()  ← カテゴリ別サマリー生成
  │   └─ selectTopHints()  ← 最重要ヒント3個を選択
  │
  └─ calculateScore()  ← スコア計算（0〜100点）
```
図3.6: 採点エンジンの関数構成

### 3.5.2 変数マッピング機能（v2.1の核心）

変数マッピング機能は、本研究の最大の技術的貢献である。この機能により、変数名が異なるプログラムでも、使用パターンが同じであれば正解と判定できる。

**問題意識**

小学生がプログラミングを学習する際、変数名を自由に設定する。以下の例を考える。

```
正解プログラム:
  変数「カウンター」を0にする
  10回繰り返す
    変数「カウンター」を1ずつ変える

生徒Aのプログラム:
  変数「りんご」を0にする
  10回繰り返す
    変数「りんご」を1ずつ変える

生徒Bのプログラム:
  変数「x」を0にする
  10回繰り返す
    変数「x」を1ずつ変える
```

生徒A、Bのプログラムは、変数名が異なるだけで、処理内容は正解と同じである。変数名で不正解と判定するのは不適切である。

**解決策: 変数の使用パターンでマッピング**

変数名ではなく、**変数がどのように使われているか**（使用パターン）を分析し、パターンが同じ変数同士をマッピングする。

**アルゴリズムの詳細**

変数マッピングのアルゴリズムを以下に示す。

**ステップ1: 変数使用パターンの抽出**

関数`buildVariableUsagePattern()`により、各変数がどのブロックでどのように使われているかを抽出する。

正解プログラムの変数「カウンター」の使用パターン:
```javascript
{
  "variableId": "var_id_123",
  "name": "カウンター",
  "usages": [
    { "opcode": "data_setvariableto", "value": 0, "position": 0 },
    { "opcode": "data_changevariableby", "value": 1, "position": 1 },
    { "opcode": "data_variable", "position": 2 }  // 変数の参照
  ]
}
```

生徒Aのプログラムの変数「りんご」の使用パターン:
```javascript
{
  "variableId": "var_id_456",
  "name": "りんご",
  "usages": [
    { "opcode": "data_setvariableto", "value": 0, "position": 0 },
    { "opcode": "data_changevariableby", "value": 1, "position": 1 },
    { "opcode": "data_variable", "position": 2 }
  ]
}
```

両者の使用パターンは同じである。

**ステップ2: パターン類似度の計算**

関数`calculatePatternSimilarity(pattern1, pattern2)`により、2つの使用パターンの類似度を計算する。

類似度は、以下の要素を考慮して0.0〜1.0のスコアで算出される。

1. **使用ブロックの一致度（重み0.5）**: 両変数が使われているブロック（opcode）の一致率
2. **初期値の一致（重み0.2）**: `data_setvariableto`で設定される初期値が近いか
3. **操作の一致（重み0.3）**: `data_changevariableby`（増減）、比較演算子での使用など

```javascript
function calculatePatternSimilarity(pattern1, pattern2) {
  let score = 0;

  // 使用ブロックの一致度
  const opcodes1 = pattern1.map(u => u.opcode);
  const opcodes2 = pattern2.map(u => u.opcode);
  const commonOpcodes = opcodes1.filter(op => opcodes2.includes(op));
  score += (commonOpcodes.length / Math.max(opcodes1.length, opcodes2.length)) * 0.5;

  // 初期値の一致
  const initialValue1 = pattern1.find(u => u.opcode === 'data_setvariableto')?.value || 0;
  const initialValue2 = pattern2.find(u => u.opcode === 'data_setvariableto')?.value || 0;
  if (Math.abs(initialValue1 - initialValue2) < 5) {
    score += 0.2;
  }

  // 増減パターンの一致
  const hasIncrement1 = pattern1.some(u => u.opcode === 'data_changevariableby');
  const hasIncrement2 = pattern2.some(u => u.opcode === 'data_changevariableby');
  if (hasIncrement1 === hasIncrement2) {
    score += 0.3;
  }

  return score;  // 0.0〜1.0
}
```

上記の例では、「カウンター」と「りんご」の類似度は1.0となる。

**ステップ3: マッピングの決定**

関数`mapVariables(correctUsage, submittedUsage)`により、類似度が最も高い変数同士をマッピングする。

```javascript
function mapVariables(correctUsage, submittedUsage) {
  const mapping = {}; // { submittedVarId: correctVarId }
  const usedCorrectVars = new Set();

  for (const [submittedVarId, submittedPattern] of Object.entries(submittedUsage)) {
    let bestMatch = null;
    let bestScore = -1;

    for (const [correctVarId, correctPattern] of Object.entries(correctUsage)) {
      if (usedCorrectVars.has(correctVarId)) continue; // 既にマッピング済み

      const score = calculatePatternSimilarity(
        submittedPattern.usages,
        correctPattern.usages
      );

      if (score > bestScore) {
        bestScore = score;
        bestMatch = correctVarId;
      }
    }

    // 類似度が0.5以上ならマッピング
    if (bestMatch && bestScore > 0.5) {
      mapping[submittedVarId] = bestMatch;
      usedCorrectVars.add(bestMatch);
    }
  }

  return mapping;
  // 例: { "var_id_456": "var_id_123" }
  //     →「りんご」は「カウンター」にマッピングされる
}
```

**ステップ4: マッピングを用いたブロック比較**

ブロック比較時、変数のフィールドを確認する際に、マッピングを適用する。

```javascript
function checkBlock(correctBlock, submittedBlock, variableMapping) {
  // 正解ブロックが変数「var_id_123」（カウンター）を参照
  if (correctBlock.fields.VARIABLE[1] === "var_id_123") {
    const correctVarId = "var_id_123";
    const submittedVarId = submittedBlock.fields.VARIABLE[1]; // "var_id_456"（りんご）

    // マッピングを確認
    if (variableMapping[submittedVarId] === correctVarId) {
      return { match: true, message: "変数が正しく使われています" };
    } else {
      return { match: false, message: "変数が異なります" };
    }
  }
}
```

上記の例では、`variableMapping["var_id_456"] === "var_id_123"`が真であるため、正解と判定される。

**効果**

変数マッピング機能により、以下の効果が得られる。

1. **学習者の創造性を尊重**: 変数名を自由に設定できる
2. **本質的な理解を評価**: 変数の役割を理解しているかを評価できる
3. **フィードバックの質向上**: 「変数名が違います」ではなく、「変数の使い方が違います」と指摘できる

### 3.5.3 セマンティック比較アルゴリズム

セマンティック比較とは、プログラムの構文（見た目）ではなく、意味（動作）を比較することである。本節では、ブロック比較のロジックを説明する。

**ブロック比較の流れ**

関数`checkBlocks(requirements, submittedProgram, variableMapping)`により、必須ブロックの存在とパラメータの妥当性を確認する。

```javascript
function checkBlocks(requirements, submittedProgram, variableMapping) {
  const results = [];

  for (let requirement of requirements.blocks) {
    const { opcode, params, optional } = requirement;

    // 1. 提出プログラムから該当ブロックを検索
    const matchingBlocks = findBlocksByOpcode(submittedProgram, opcode);

    if (matchingBlocks.length === 0) {
      // ブロックが見つからない
      if (optional) {
        results.push({
          type: 'warning',
          priority: 1, // MEDIUM
          message: `推奨ブロック「${getBlockDisplayName(opcode)}」が見つかりません`,
          category: getBlockCategory(opcode)
        });
      } else {
        results.push({
          type: 'error',
          priority: 3, // CRITICAL
          message: `必須ブロック「${getBlockDisplayName(opcode)}」が見つかりません`,
          hint: `「${getBlockCategoryName(opcode)}」カテゴリから「${getBlockDisplayName(opcode)}」ブロックを追加してみましょう`,
          category: getBlockCategory(opcode)
        });
      }
      continue;
    }

    // 2. パラメータの比較
    for (let block of matchingBlocks) {
      const paramResult = compareParameters(
        params,
        block,
        variableMapping
      );

      if (paramResult.match) {
        results.push({
          type: paramResult.perfect ? 'success' : 'warning',
          priority: paramResult.perfect ? 0 : 1,
          message: paramResult.message,
          category: getBlockCategory(opcode)
        });
        break;  // 1つでも一致すればOK
      }
    }
  }

  return results;
}
```

**パラメータの柔軟マッチング**

関数`compareParameters(expectedParams, actualBlock, variableMapping)`により、ブロックのパラメータを比較する。

```javascript
function compareParameters(expectedParams, actualBlock, variableMapping) {
  for (let paramName of Object.keys(expectedParams)) {
    const expected = expectedParams[paramName];
    const actual = getInputValue(actualBlock, paramName);

    // 数値の場合: ±10%許容
    if (typeof expected === 'number' && typeof actual === 'number') {
      const diff = Math.abs(expected - actual);
      const tolerance = expected * 0.1;

      if (diff === 0) {
        return {
          match: true,
          perfect: true,
          message: `「${paramName}」の値が正確です（${expected}）`
        };
      } else if (diff <= tolerance) {
        return {
          match: true,
          perfect: false,
          message: `「${paramName}」の値が少し違います（正解: ${expected}、あなた: ${actual}）`
        };
      } else {
        return {
          match: false,
          message: `「${paramName}」の値が間違っています（正解: ${expected}、あなた: ${actual}）`
        };
      }
    }

    // 変数の場合: マッピングを考慮
    if (expected.type === 'variable') {
      const expectedVarId = expected.id;
      const actualVarId = actual.id;

      if (variableMapping[actualVarId] === expectedVarId) {
        return {
          match: true,
          perfect: true,
          message: `変数が正しく使われています`
        };
      } else {
        return {
          match: false,
          message: `変数が異なります`
        };
      }
    }

    // 文字列の場合: 正規化して比較
    if (typeof expected === 'string') {
      const normalizedExpected = normalizeString(expected);
      const normalizedActual = normalizeString(actual);

      if (normalizedExpected === normalizedActual) {
        return {
          match: true,
          perfect: true,
          message: `「${paramName}」の値が正確です`
        };
      } else {
        return {
          match: false,
          message: `「${paramName}」の値が違います（正解: ${expected}、あなた: ${actual}）`
        };
      }
    }
  }
}
```

**ブロック順序の柔軟性**

一部のブロックは、順序を問わない。例えば、「緑の旗がクリックされたとき」イベントブロックは、スクリプトの先頭に配置されるが、複数のスクリプトがある場合、その順序は関係ない。また、「見た目」ブロック（例：「Hello!と言う」「大きさを100%にする」）も、動作に影響を与えない限り順序を問わない。

```javascript
const orderIndependentBlocks = [
  'event_whenflagclicked',  // 旗クリックイベント
  'looks_say',              // 見た目: 言う
  'looks_think',            // 見た目: 考える
  'looks_setsize',          // 見た目: 大きさを設定
];

function checkOrderConstraints(requirements, submittedProgram) {
  const results = [];

  for (let constraint of requirements.orderConstraints) {
    const { block1, block2 } = constraint;

    // 順序を問わないブロックはスキップ
    if (orderIndependentBlocks.includes(block1.opcode) ||
        orderIndependentBlocks.includes(block2.opcode)) {
      continue;
    }

    // block1がblock2より前にあるか確認
    const position1 = findBlockPosition(submittedProgram, block1);
    const position2 = findBlockPosition(submittedProgram, block2);

    if (position1 !== null && position2 !== null && position1 > position2) {
      results.push({
        type: 'error',
        priority: 3, // CRITICAL
        message: `「${getBlockDisplayName(block1.opcode)}」は「${getBlockDisplayName(block2.opcode)}」の前にある必要があります`,
        category: 'order'
      });
    }
  }

  return results;
}
```

### 3.5.4 フィードバック生成ロジック（v2.3の改善）

フィードバック生成は、v2.3で大幅に改善された。改善点は以下の3つである。

**1. エラーの優先度付け**

エラーを重要度順に表示することで、学習者がどこから修正すべきか一目で分かる。

優先度の定義:
- **CRITICAL（優先度3）**: ブロックが完全に欠けている
- **HIGH（優先度2）**: 値が大幅に間違っている
- **MEDIUM（優先度1）**: 値が少し違う、余分な要素がある
- **SUCCESS（優先度0）**: 正解（v2.3では非表示）

```javascript
const PRIORITY = {
  SUCCESS: 0,
  MEDIUM: 1,
  HIGH: 2,
  CRITICAL: 3
};

function prioritizeErrors(details) {
  // 成功メッセージを除外
  const nonSuccessDetails = details.filter(d => d.type !== 'success');

  // 優先度順にソート（高い順）
  nonSuccessDetails.sort((a, b) => b.priority - a.priority);

  return nonSuccessDetails;
}
```

**2. 正解している部分は表示しない**

v2.2以前では、正解しているブロックも「✓ 正しく使われています」と表示していたが、v2.3ではこれを削除した。これにより、学習者は間違いに集中でき、フィードバックが簡潔になる。

**3. カテゴリ別サマリー**

エラーが3個以上ある場合、問題の多いカテゴリ（動き、制御、見た目など）を強調表示する。

```javascript
function generateCategorySummary(details) {
  const categoryCount = {};

  // カテゴリごとのエラー数を集計
  for (const detail of details) {
    if (detail.type === 'error' && detail.category) {
      categoryCount[detail.category] = (categoryCount[detail.category] || 0) + 1;
    }
  }

  // エラー数が多い順にソート
  const sortedCategories = Object.entries(categoryCount)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3);  // 最大3個

  if (sortedCategories.length > 0) {
    const categoryText = sortedCategories
      .map(([cat, count]) => `${getCategoryDisplayName(cat)}(${count}個)`)
      .join('、');
    return ` 問題の多いカテゴリ: ${categoryText}`;
  }

  return '';
}
```

**4. ヒントは最大3個まで**

ヒントが多すぎると学習者が混乱するため、最も重要なヒント3個のみを表示する。ヒントは優先度順にソートし、重複を削除する。

```javascript
function selectTopHints(allHints) {
  const uniqueHints = [];
  const seenMessages = new Set();

  // 優先度順にソート
  allHints.sort((a, b) => b.priority - a.priority);

  for (const hint of allHints) {
    if (!seenMessages.has(hint.message) && uniqueHints.length < 3) {
      uniqueHints.push(hint.message);
      seenMessages.add(hint.message);
    }
  }

  return uniqueHints;
}
```

**フィードバック生成の統合**

関数`generateFeedback(blockResults, orderResults)`により、最終的なフィードバックを生成する。

```javascript
function generateFeedback(blockResults, orderResults) {
  const allDetails = [...blockResults, ...orderResults];

  // 1. エラーを優先度順にソート、成功メッセージを除外
  const prioritizedDetails = prioritizeErrors(allDetails);

  // 2. ヒントを抽出し、最大3個選択
  const allHints = allDetails
    .filter(d => d.hint)
    .map(d => ({ message: d.hint, priority: d.priority }));
  const selectedHints = selectTopHints(allHints);

  // 3. スコア計算
  const score = calculateScore(allDetails);

  // 4. サマリー生成
  let summary;
  if (score === 100) {
    summary = '完璧です！';
  } else if (score >= 90) {
    summary = `${score}点: あともう一歩！`;
  } else if (score >= 80) {
    summary = `${score}点: よくできました！`;
  } else if (score >= 60) {
    summary = `${score}点: もう一息！`;
  } else {
    summary = `${score}点: もう一度チャレンジしてみましょう`;
  }

  // 5. カテゴリ別サマリー追加（エラーが3個以上の場合）
  const errorCount = prioritizedDetails.filter(d => d.type === 'error').length;
  if (errorCount >= 3) {
    summary += generateCategorySummary(prioritizedDetails);
  }

  return {
    summary: summary,
    details: prioritizedDetails,
    hints: selectedHints
  };
}
```

---

## 3.6 4種類の問題タイプ

本システムでは、段階的に思考力を育成するため、4種類の問題タイプを提供する。各タイプは、異なる認知能力を育成する。

### 3.6.1 穴埋め式問題（fill_blank）

**目的**: プログラムの基本的な構造を理解する

**問題例**

問題文:
```
ネコのスプライトを10歩前に進めるプログラムを完成させよう。
「○○歩動かす」の○○に正しい数字を入れてください。
```

初期プログラム:
```
緑の旗がクリックされたとき
  [  ]歩動かす    ← ここに10を入れる
```

正解プログラム:
```
緑の旗がクリックされたとき
  10歩動かす
```

**学習のポイント**

1. ブロックの意味を理解する
2. 数値パラメータの設定方法を学ぶ
3. 文脈から適切な値を推測する力を養う

**採点のポイント**

1. 「10歩動かす」ブロックの存在を確認
2. パラメータが10（または±1程度、±10%許容）であることを確認

**難易度設定**

- レベル1（★☆☆☆☆）: 1つの値を埋める（例：移動距離のみ）
- レベル2（★★☆☆☆）: 2〜3個の値を埋める（例：移動距離と回転角度）
- レベル3（★★★☆☆）: ブロック自体も選択が必要（例：「動き」カテゴリから適切なブロックを選ぶ）

**実装例**

初期SB3データ:
```json
{
  "targets": [{
    "blocks": {
      "block1": {
        "opcode": "event_whenflagclicked",
        "next": "block2"
      },
      "block2": {
        "opcode": "motion_movesteps",
        "inputs": {
          "STEPS": [1, [4, ""]]  // 空欄
        }
      }
    }
  }]
}
```

正解SB3データ:
```json
{
  "targets": [{
    "blocks": {
      "block1": {
        "opcode": "event_whenflagclicked",
        "next": "block2"
      },
      "block2": {
        "opcode": "motion_movesteps",
        "inputs": {
          "STEPS": [1, [4, "10"]]  // 正解: 10
        }
      }
    }
  }]
}
```

### 3.6.2 予測問題（predict）

**目的**: プログラムの実行結果を予測する力を養う

**問題例**

問題文:
```
次のプログラムを実行すると、スプライトはどこに移動するでしょうか？
Scratchで実行して確認し、最終的な位置を記録した.sb3ファイルを提出してください。
```

プログラム:
```
緑の旗がクリックされたとき
  X座標を0、Y座標を0にする
  10歩動かす
  右に15度回す
  20歩動かす
```

質問:
```
最終的なスプライトの位置（X座標、Y座標）と向きは？
```

**実装方法**

本システムでは、予測問題を以下のように実装している。

1. 初期SB3に「予測すべきプログラム」が含まれている
2. 学習者は実際にScratchで実行して確認
3. 正解の最終状態（座標、向きなど）を持つSB3を提出

採点時は、提出されたSB3ファイルのスプライトの座標・向きが正解と一致するかを確認する。

```javascript
function checkPredictProblem(correctSB3, submittedSB3) {
  const correctSprite = correctSB3.targets.find(t => !t.isStage);
  const submittedSprite = submittedSB3.targets.find(t => !t.isStage);

  const correctX = correctSprite.x;
  const correctY = correctSprite.y;
  const correctDirection = correctSprite.direction;

  const submittedX = submittedSprite.x;
  const submittedY = submittedSprite.y;
  const submittedDirection = submittedSprite.direction;

  const xDiff = Math.abs(correctX - submittedX);
  const yDiff = Math.abs(correctY - submittedY);
  const directionDiff = Math.abs(correctDirection - submittedDirection);

  let score = 100;
  const feedback = [];

  if (xDiff <= 5 && yDiff <= 5 && directionDiff <= 5) {
    feedback.push({ type: 'success', message: '完璧です！位置と向きが正確です' });
  } else {
    if (xDiff > 5) {
      feedback.push({
        type: 'error',
        message: `X座標が違います（正解: ${correctX}, あなた: ${submittedX}）`
      });
      score -= 30;
    }
    if (yDiff > 5) {
      feedback.push({
        type: 'error',
        message: `Y座標が違います（正解: ${correctY}, あなた: ${submittedY}）`
      });
      score -= 30;
    }
    if (directionDiff > 5) {
      feedback.push({
        type: 'error',
        message: `向きが違います（正解: ${correctDirection}度, あなた: ${submittedDirection}度）`
      });
      score -= 20;
    }
  }

  return { score, feedback };
}
```

**学習のポイント**

1. プログラムの実行フローを追う力
2. 各ブロックの効果を理解する
3. 座標系、角度の概念を学ぶ

**採点のポイント**

1. 最終的なスプライトの座標が正しいか（±5ピクセル許容）
2. 向きが正しいか（±5度許容）

### 3.6.3 間違い探し問題（find_error）

**目的**: デバッグ能力を養う

**問題例**

問題文:
```
次のプログラムは「ネコが正方形を描く」プログラムですが、正しく動きません。
間違いを見つけて修正してください。
```

バグのあるプログラム:
```
緑の旗がクリックされたとき
  ペンを下ろす
  3回繰り返す          ← 間違い！（4回であるべき）
    50歩動かす
    90度回す
  ペンを上げる
```

正解プログラム:
```
緑の旗がクリックされたとき
  ペンを下ろす
  4回繰り返す          ← 修正
    50歩動かす
    90度回す
  ペンを上げる
```

**バグの種類**（段階的に難易度設定）

1. **数値の間違い**: 繰り返し回数、移動距離、角度など
2. **ブロックの欠落**: 必要なブロックが抜けている
3. **ブロックの順序**: 順番が間違っている
4. **論理的エラー**: 条件分岐の条件が逆など

**学習のポイント**

1. プログラムを読み解く力
2. 期待される動作と実際の動作の差異を発見する
3. 原因を特定し修正する力

**採点のポイント**

1. 正しく修正されたブロックの確認（例：繰り返し回数が4に修正されているか）
2. 意図した動作が実現できているか（例：正方形が正しく描画されるか）

**実装例**

初期SB3データ（バグあり）:
```json
{
  "targets": [{
    "blocks": {
      "block1": {
        "opcode": "event_whenflagclicked",
        "next": "block2"
      },
      "block2": {
        "opcode": "pen_penDown",
        "next": "block3"
      },
      "block3": {
        "opcode": "control_repeat",
        "inputs": {
          "TIMES": [1, [4, "3"]],  // バグ: 3回（正しくは4回）
          "SUBSTACK": ["block4"]
        },
        "next": "block6"
      },
      "block4": {
        "opcode": "motion_movesteps",
        "inputs": { "STEPS": [1, [4, "50"]] },
        "next": "block5"
      },
      "block5": {
        "opcode": "motion_turnright",
        "inputs": { "DEGREES": [1, [4, "90"]] }
      },
      "block6": {
        "opcode": "pen_penUp"
      }
    }
  }]
}
```

正解SB3データ:
```json
{
  "targets": [{
    "blocks": {
      // ... 同じ構造だが、block3のTIMESが "4"
      "block3": {
        "opcode": "control_repeat",
        "inputs": {
          "TIMES": [1, [4, "4"]],  // 修正: 4回
          "SUBSTACK": ["block4"]
        },
        "next": "block6"
      }
    }
  }]
}
```

採点時は、繰り返し回数が4に修正されているかを確認する。

### 3.6.4 ミッション型問題（mission）

**目的**: 知識を統合して創造的に問題を解決する

**問題例**

問題文:
```
【ミッション】
迷路を脱出するプログラムを作ろう！

【条件】
- スタート地点から始める
- 壁にぶつからないように進む
- ゴール地点に到達する
- 繰り返しや条件分岐を使って効率的に

【初期状態】
- 迷路のステージが用意されている
- スプライトはスタート地点に配置済み

【評価基準】
- ゴールに到達できたか（必須）
- 使用したブロック数（少ないほど高評価）
- 繰り返しを活用しているか
```

**学習のポイント**

1. これまで学んだ知識の統合
2. 問題を分解して考える力
3. 試行錯誤しながら解決策を見つける

**採点のポイント**（複合的）

1. **最低限の要件**: ゴール到達（必須ブロックの存在）
2. **効率性**: ブロック数が少ない、繰り返しを活用
3. **創造性**: ユニークな解法（ボーナス点）

**採点の実装**

ミッション型問題は、複数の観点で評価する。

```javascript
function gradeMissionProblem(correctSB3, submittedSB3) {
  let score = 0;
  const feedback = [];

  // 1. ゴール到達の確認
  const hasGoalReached = checkFinalPosition(
    submittedSB3,
    correctSB3.goalPosition
  );

  if (hasGoalReached) {
    score += 70;  // 基本点
    feedback.push({
      type: 'success',
      message: 'ゴールに到達できました！'
    });
  } else {
    feedback.push({
      type: 'error',
      message: 'ゴールに到達できていません',
      hint: 'スプライトの移動距離と向きを確認してみましょう'
    });
    return { score, isCorrect: false, feedback };
  }

  // 2. 繰り返しブロックの使用確認
  const usesLoop = findBlocksByOpcode(submittedSB3, 'control_repeat').length > 0 ||
                   findBlocksByOpcode(submittedSB3, 'control_forever').length > 0;

  if (usesLoop) {
    score += 20;  // 繰り返し使用
    feedback.push({
      type: 'success',
      message: '繰り返しブロックを活用しています！'
    });
  } else {
    feedback.push({
      type: 'warning',
      message: '繰り返しブロックを使うともっと効率的になります',
      hint: '「制御」カテゴリから「○回繰り返す」ブロックを使ってみましょう'
    });
  }

  // 3. 効率性（ブロック数）
  const blockCount = countBlocks(submittedSB3);
  const optimalBlockCount = countBlocks(correctSB3);

  if (blockCount <= optimalBlockCount) {
    score += 10;  // 効率性
    feedback.push({
      type: 'success',
      message: `ブロック数が少なく、効率的です！（${blockCount}個）`
    });
  } else if (blockCount <= optimalBlockCount * 1.5) {
    score += 5;  // 部分点
    feedback.push({
      type: 'warning',
      message: `ブロック数がやや多いです（${blockCount}個、最適: ${optimalBlockCount}個）`,
      hint: '同じ処理を繰り返している部分はありませんか？'
    });
  } else {
    feedback.push({
      type: 'warning',
      message: `ブロック数が多すぎます（${blockCount}個、最適: ${optimalBlockCount}個）`,
      hint: '繰り返しブロックを使うと、プログラムを短くできます'
    });
  }

  return { score, isCorrect: score >= 70, feedback };
}
```

---

以上、第3章「提案」では、本システムの概要、使用技術、Webアプリケーションの詳細、データベース設計、自動採点エンジン、4種類の問題タイプについて説明した。特に、採点エンジンの変数マッピング機能（v2.1）と優先度付きフィードバック（v2.3）は、本研究の主要な技術的貢献である。
